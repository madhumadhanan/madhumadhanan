<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Madhu Madhanan - Galactic Profile</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Courier New', monospace;
            background: #000000;
            overflow: hidden;
            width: 100vw;
            height: 100vh;
        }

        #container {
            width: 100%;
            height: 100%;
            position: relative;
        }

        #info {
            position: absolute;
            bottom: 30px;
            left: 50%;
            transform: translateX(-50%);
            color: #ffffff;
            font-size: 14px;
            text-align: center;
            z-index: 10;
            letter-spacing: 2px;
            text-shadow: 0 0 10px #4a90e2;
            opacity: 0.8;
            pointer-events: none;
        }

        .loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #ffffff;
            font-size: 18px;
            letter-spacing: 3px;
            transition: opacity 0.5s;
        }
    </style>
</head>
<body>
    <div id="container"></div>
    <div id="info">AI • INNOVATION • FUTURE</div>
    <div class="loading" id="loading">INITIALIZING SYSTEMS...</div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    
    <script>
        let scene, camera, renderer;
        let textMesh1, textMesh2, bgPlane;
        let particles = [];
        let comets = [];
        let explosions = [];
        let letters = []; // Store all active letter meshes for collision detection
        let isResetting = false;

        const container = document.getElementById('container');
        
        // Configuration
        const SETTINGS = {
            cometCount: 6,
            starCount: 1500,
            imagePath: 'Madhu.jpg' // ENSURE THIS FILE EXISTS IN THE FOLDER
        };

        function init() {
            scene = new THREE.Scene();
            // Deep space fog
            scene.fog = new THREE.FogExp2(0x050510, 0.02);
            scene.background = new THREE.Color(0x050510);

            const aspect = window.innerWidth / window.innerHeight;
            camera = new THREE.PerspectiveCamera(45, aspect, 0.1, 1000);
            camera.position.z = window.innerWidth < 768 ? 22 : 15;

            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            // Enable shadow map for depth
            renderer.shadowMap.enabled = true;
            container.appendChild(renderer.domElement);

            // Lighting
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.4);
            scene.add(ambientLight);

            const spotLight = new THREE.SpotLight(0x4a90e2, 1);
            spotLight.position.set(10, 10, 20);
            spotLight.angle = 0.5;
            spotLight.penumbra = 1;
            scene.add(spotLight);

            const pointLight = new THREE.PointLight(0xff4400, 0.8, 20); // Orange light for contrast
            pointLight.position.set(-5, -5, 5);
            scene.add(pointLight);

            createBackgroundProfile();
            createStarField();
            createText();
            createComets();

            document.getElementById('loading').style.display = 'none';

            animate();
        }

        function createBackgroundProfile() {
            const textureLoader = new THREE.TextureLoader();
            
            textureLoader.load(SETTINGS.imagePath, function(texture) {
                // Image Loaded Successfully
                const geometry = new THREE.PlaneGeometry(12, 12); // Square plane
                const material = new THREE.MeshPhongMaterial({ 
                    map: texture,
                    transparent: true,
                    opacity: 0.3, // Subtle blending
                    blending: THREE.AdditiveBlending,
                    side: THREE.DoubleSide
                });
                
                bgPlane = new THREE.Mesh(geometry, material);
                bgPlane.position.z = -8;
                scene.add(bgPlane);
            }, undefined, function(err) {
                console.warn('Image not found. Ensure Madhu.jpg is in the folder.');
                // Fallback if image missing
                const geometry = new THREE.PlaneGeometry(10, 10);
                const material = new THREE.MeshBasicMaterial({ color: 0x111122, wireframe: true });
                bgPlane = new THREE.Mesh(geometry, material);
                bgPlane.position.z = -8;
                scene.add(bgPlane);
            });
        }

        function createText() {
            // Clear existing letters if any
            letters = [];
            if(textMesh1) scene.remove(textMesh1);
            if(textMesh2) scene.remove(textMesh2);

            createWord('MADHU', 2.0, true);
            createWord('MADHANAN', -2.0, false);
        }

        function createWord(text, yPos, isFirst) {
            const group = new THREE.Group();
            const isMobile = window.innerWidth < 768;
            const letterSpacing = isMobile ? 1.2 : 1.5;
            const totalWidth = text.length * letterSpacing;
            const startX = -totalWidth / 2;

            for (let i = 0; i < text.length; i++) {
                const letter = text[i];
                const letterMesh = createLetterMesh(letter);
                
                // Position
                letterMesh.position.x = startX + i * letterSpacing + (letterSpacing/2);
                
                // Add Metadata for game logic
                letterMesh.userData = {
                    initialY: yPos,
                    id: Math.random(),
                    health: 100,
                    isDestroyed: false,
                    offset: i // For animation phase
                };

                group.add(letterMesh);
                letters.push(letterMesh); // Add to global collision array
            }

            group.position.y = yPos;
            scene.add(group);

            if (isFirst) textMesh1 = group;
            else textMesh2 = group;
        }

        function createLetterMesh(char) {
            const shape = new THREE.Shape();
            
            // Define basic blocky font paths
            const w = 0.4; // width factor
            const h = 1.0; // height
            
            // Helper to draw letters
            const draw = {
                'M': () => { shape.moveTo(-w,0); shape.lineTo(-w,h); shape.lineTo(0,h/2); shape.lineTo(w,h); shape.lineTo(w,0); shape.lineTo(w/2,0); shape.lineTo(w/2,0.6); shape.lineTo(0,0.2); shape.lineTo(-w/2,0.6); shape.lineTo(-w/2,0); },
                'A': () => { shape.moveTo(-w,0); shape.lineTo(0,h); shape.lineTo(w,0); shape.lineTo(w/2,0); shape.lineTo(w/4,0.3); shape.lineTo(-w/4,0.3); shape.lineTo(-w/2,0); },
                'D': () => { shape.moveTo(-w,0); shape.lineTo(-w,h); shape.lineTo(0,h); shape.quadraticCurveTo(w,h,w,h/2); shape.quadraticCurveTo(w,0,0,0); },
                'H': () => { shape.moveTo(-w,0); shape.lineTo(-w,h); shape.lineTo(-w/2,h); shape.lineTo(-w/2,0.6); shape.lineTo(w/2,0.6); shape.lineTo(w/2,h); shape.lineTo(w,h); shape.lineTo(w,0); shape.lineTo(w/2,0); shape.lineTo(w/2,0.4); shape.lineTo(-w/2,0.4); shape.lineTo(-w/2,0); },
                'U': () => { shape.moveTo(-w,h); shape.lineTo(-w,0.3); shape.quadraticCurveTo(-w,0,0,0); shape.quadraticCurveTo(w,0,w,0.3); shape.lineTo(w,h); shape.lineTo(w/2,h); shape.lineTo(w/2,0.3); shape.quadraticCurveTo(w/2,0.2,0,0.2); shape.quadraticCurveTo(-w/2,0.2,-w/2,0.3); shape.lineTo(-w/2,h); },
                'N': () => { shape.moveTo(-w,0); shape.lineTo(-w,h); shape.lineTo(-w/2,h); shape.lineTo(w/2,0.3); shape.lineTo(w/2,h); shape.lineTo(w,h); shape.lineTo(w,0); shape.lineTo(w/2,0); shape.lineTo(-w/2,0.7); shape.lineTo(-w/2,0); }
            };

            if (draw[char]) draw[char]();
            else { 
                // Fallback box for unknown chars
                shape.moveTo(-w,0); shape.lineTo(-w,h); shape.lineTo(w,h); shape.lineTo(w,0); 
            }

            const geometry = new THREE.ExtrudeGeometry(shape, {
                depth: 0.2,
                bevelEnabled: true,
                bevelThickness: 0.03,
                bevelSize: 0.02,
                bevelSegments: 3
            });
            geometry.center();

            const material = new THREE.MeshPhongMaterial({ 
                color: 0xffffff,
                emissive: 0x224466,
                shininess: 60,
                specular: 0x4a90e2
            });

            const mesh = new THREE.Mesh(geometry, material);
            return mesh;
        }

        function createStarField() {
            const geometry = new THREE.BufferGeometry();
            const positions = [];
            const colors = [];

            const colorPalette = [
                new THREE.Color(0xffffff), // White
                new THREE.Color(0x4a90e2), // Blue
                new THREE.Color(0xffaa00)  // Gold
            ];

            for (let i = 0; i < SETTINGS.starCount; i++) {
                const x = (Math.random() - 0.5) * 80;
                const y = (Math.random() - 0.5) * 80;
                const z = (Math.random() - 0.5) * 60 - 10;
                positions.push(x, y, z);

                const color = colorPalette[Math.floor(Math.random() * colorPalette.length)];
                colors.push(color.r, color.g, color.b);
            }

            geometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
            geometry.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));

            const material = new THREE.PointsMaterial({
                size: 0.15,
                vertexColors: true,
                transparent: true,
                opacity: 0.8,
                blending: THREE.AdditiveBlending
            });

            const starSystem = new THREE.Points(geometry, material);
            scene.add(starSystem);
            particles.push(starSystem);
        }

        function createComets() {
            for (let i = 0; i < SETTINGS.cometCount; i++) {
                createSingleComet();
            }
        }

        function createSingleComet() {
            // Head
            const geometry = new THREE.SphereGeometry(0.08, 8, 8);
            const material = new THREE.MeshBasicMaterial({ color: 0xffaa00 });
            const comet = new THREE.Mesh(geometry, material);

            // Trail
            const trailGeo = new THREE.BufferGeometry();
            const positions = new Float32Array(30 * 3); // 30 segments
            trailGeo.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            const trailMat = new THREE.LineBasicMaterial({
                color: 0xff4400,
                transparent: true,
                opacity: 0.6
            });
            const trail = new THREE.Line(trailGeo, trailMat);
            scene.add(trail);

            // Comet Data
            comet.userData = {
                velocity: new THREE.Vector3(),
                trailMesh: trail,
                trailPoints: [],
                target: null // Will aim at a letter
            };
            
            resetComet(comet);
            scene.add(comet);
            comets.push(comet);
        }

        function resetComet(comet) {
            // Pick a random living letter as target
            const liveLetters = letters.filter(l => !l.userData.isDestroyed);
            
            // Start position (random off-screen)
            const side = Math.random() > 0.5 ? 1 : -1;
            comet.position.set(
                (Math.random() - 0.5) * 30,
                15, // Start high
                (Math.random() - 0.5) * 10
            );

            // Calculate velocity towards a target or random center point
            let targetPos = new THREE.Vector3(0, 0, 0);
            if(liveLetters.length > 0) {
                // Aim at a random living letter + slight jitter so not perfect accuracy
                const targetLetter = liveLetters[Math.floor(Math.random() * liveLetters.length)];
                // Need absolute world position of letter
                const vector = new THREE.Vector3();
                targetLetter.getWorldPosition(vector);
                targetPos.copy(vector);
                targetPos.x += (Math.random() - 0.5) * 1.5; // Jitter
            } else {
                targetPos.set((Math.random() - 0.5) * 10, -10, 0);
            }

            // Direction vector
            const dir = new THREE.Vector3().subVectors(targetPos, comet.position).normalize();
            const speed = 0.2 + Math.random() * 0.3; // Speed
            comet.userData.velocity = dir.multiplyScalar(speed);
            comet.userData.trailPoints = [];
        }

        function createExplosion(position) {
            const particleCount = 20;
            const geometry = new THREE.BufferGeometry();
            const positions = [];
            const velocities = [];

            for (let i = 0; i < particleCount; i++) {
                positions.push(position.x, position.y, position.z);
                velocities.push({
                    x: (Math.random() - 0.5) * 0.4,
                    y: (Math.random() - 0.5) * 0.4,
                    z: (Math.random() - 0.5) * 0.4
                });
            }

            geometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
            
            const material = new THREE.PointsMaterial({
                color: 0xff5500,
                size: 0.2,
                transparent: true,
                opacity: 1
            });

            const explosion = new THREE.Points(geometry, material);
            explosion.userData = {
                velocities: velocities,
                life: 1.0 // 1 second life
            };
            
            scene.add(explosion);
            explosions.push(explosion);
        }

        function checkReset() {
            if(isResetting) return;

            const liveLetters = letters.filter(l => !l.userData.isDestroyed);
            if(liveLetters.length === 0 && letters.length > 0) {
                isResetting = true;
                setTimeout(() => {
                    // Respawn logic
                    letters.forEach(l => {
                        l.visible = true;
                        l.userData.isDestroyed = false;
                        l.scale.set(1,1,1);
                    });
                    isResetting = false;
                }, 2000); // Wait 2 seconds before reset
            }
        }

        function animate() {
            requestAnimationFrame(animate);

            const time = Date.now() * 0.001;

            // 1. Fluid Background Animation
            if(bgPlane) {
                bgPlane.rotation.z = Math.sin(time * 0.1) * 0.05;
                bgPlane.position.y = Math.cos(time * 0.2) * 0.5;
                bgPlane.position.x = Math.sin(time * 0.15) * 0.3;
            }

            // 2. Text Fluid Animation (Only visible ones)
            letters.forEach(letter => {
                if(!letter.userData.isDestroyed) {
                    const offset = letter.userData.offset;
                    // World position update handled by group, but local rotation/pos here
                    letter.rotation.y = Math.sin(time * 1.5 + offset * 0.3) * 0.1;
                    letter.position.y = Math.sin(time * 2 + offset * 0.5) * 0.1;
                }
            });

            // 3. Move Text Groups
            if (textMesh1) textMesh1.position.y = 2.0 + Math.sin(time * 0.5) * 0.2;
            if (textMesh2) textMesh2.position.y = -2.0 + Math.sin(time * 0.5 + 2) * 0.2;

            // 4. Comet Physics & Collision
            const raycaster = new THREE.Raycaster();
            
            comets.forEach(comet => {
                // Move comet
                comet.position.add(comet.userData.velocity);

                // Update Trail
                comet.userData.trailPoints.unshift(comet.position.clone());
                if(comet.userData.trailPoints.length > 20) comet.userData.trailPoints.pop();
                
                const positions = comet.userData.trailMesh.geometry.attributes.position.array;
                let idx = 0;
                comet.userData.trailPoints.forEach(p => {
                    positions[idx++] = p.x;
                    positions[idx++] = p.y;
                    positions[idx++] = p.z;
                });
                // Fill rest of buffer with last point to prevent glitches
                while(idx < positions.length) {
                    const last = comet.userData.trailPoints[comet.userData.trailPoints.length-1] || comet.position;
                    positions[idx++] = last.x;
                    positions[idx++] = last.y;
                    positions[idx++] = last.z;
                }
                comet.userData.trailMesh.geometry.attributes.position.needsUpdate = true;

                // --- COLLISION DETECTION ---
                // We use raycasting from comet current pos in direction of velocity
                const direction = comet.userData.velocity.clone().normalize();
                raycaster.set(comet.position, direction);
                
                // Only check living letters
                const livingMeshes = letters.filter(l => !l.userData.isDestroyed);
                
                // Raycast length check (move speed)
                const hitInfo = raycaster.intersectObjects(livingMeshes);
                
                if (hitInfo.length > 0 && hitInfo[0].distance < 0.5) {
                    // HIT!
                    const hitObject = hitInfo[0].object;
                    
                    // 1. Create Explosion
                    createExplosion(hitInfo[0].point);
                    
                    // 2. Destroy Letter
                    hitObject.visible = false;
                    hitObject.userData.isDestroyed = true;
                    
                    // 3. Reset Comet immediately
                    resetComet(comet);
                }

                // Reset comet if off screen
                if(comet.position.y < -15 || Math.abs(comet.position.x) > 25) {
                    resetComet(comet);
                }
            });

            // 5. Explosion Animation
            for(let i = explosions.length - 1; i >= 0; i--) {
                const exp = explosions[i];
                exp.userData.life -= 0.02;
                
                const pos = exp.geometry.attributes.position.array;
                const vels = exp.userData.velocities;
                
                for(let j = 0; j < vels.length; j++) {
                    pos[j*3] += vels[j].x;
                    pos[j*3+1] += vels[j].y;
                    pos[j*3+2] += vels[j].z;
                }
                exp.geometry.attributes.position.needsUpdate = true;
                exp.material.opacity = exp.userData.life;

                if(exp.userData.life <= 0) {
                    scene.remove(exp);
                    explosions.splice(i, 1);
                }
            }

            // 6. Check Game Loop Reset
            checkReset();

            renderer.render(scene, camera);
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            camera.position.z = window.innerWidth < 768 ? 22 : 15;
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        window.addEventListener('resize', onWindowResize);
        window.addEventListener('load', init);
    </script>
</body>
</html>
