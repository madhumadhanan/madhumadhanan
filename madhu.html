<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Madhu Madhanan - Warp Drive</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Courier New', monospace;
            background: #000000;
            overflow: hidden;
            width: 100vw;
            height: 100vh;
        }

        #container {
            width: 100%;
            height: 100%;
            position: relative;
            /* Radial gradient overlay to enhance the warp tunnel effect */
            background: radial-gradient(circle at center, transparent 30%, #000000 100%);
        }

        #info {
            position: absolute;
            bottom: 30px;
            left: 50%;
            transform: translateX(-50%);
            color: #ffffff;
            font-size: 14px;
            text-align: center;
            z-index: 10;
            letter-spacing: 4px;
            text-shadow: 0 0 10px #4a90e2;
            opacity: 0.8;
            pointer-events: none;
        }

        .loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #ffffff;
            font-size: 18px;
            letter-spacing: 3px;
            transition: opacity 0.5s;
        }
    </style>
</head>
<body>
    <div id="container"></div>
    <div id="info">ENGAGING WARP DRIVE</div>
    <div class="loading" id="loading">INITIALIZING WARP SYSTEMS...</div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    
    <script>
        let scene, camera, renderer;
        let textMesh1, textMesh2, bgPlane;
        let warpStars; // Replaces static particles
        let comets = [];
        let explosions = [];
        let letters = []; 
        let isResetting = false;

        const container = document.getElementById('container');
        
        // Configuration
        const SETTINGS = {
            cometCount: 5,
            warpStarCount: 4000, // Increased count for dense warp effect
            warpSpeed: 2.5, // Speed of stars moving past camera
            imagePath: 'Madhu.jpg' 
        };

        function init() {
            scene = new THREE.Scene();
            // Darker fog for deeper space feel
            scene.fog = new THREE.FogExp2(0x000000, 0.015);
            scene.background = new THREE.Color(0x000000);

            const aspect = window.innerWidth / window.innerHeight;
            camera = new THREE.PerspectiveCamera(60, aspect, 0.1, 1000);
            // Moved camera closer for more intense perspective
            camera.position.z = window.innerWidth < 768 ? 18 : 12;

            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            container.appendChild(renderer.domElement);

            // Lighting
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
            scene.add(ambientLight);

            const spotLight = new THREE.SpotLight(0x4a90e2, 2);
            spotLight.position.set(0, 20, 10);
            spotLight.angle = 0.3;
            spotLight.penumbra = 1;
            scene.add(spotLight);
            
            // Blue rim light from below
            const rimLight = new THREE.PointLight(0x0066ff, 1, 30);
            rimLight.position.set(0, -10, 5);
            scene.add(rimLight);

            createBackgroundProfile();
            createWarpField(); // Changed from static starfield
            createText();
            createComets();

            document.getElementById('loading').style.display = 'none';

            animate();
        }

        function createBackgroundProfile() {
            const textureLoader = new THREE.TextureLoader();
            textureLoader.load(SETTINGS.imagePath, function(texture) {
                // CHANGE: Made size smaller (5x5 instead of 12x12)
                const geometry = new THREE.PlaneGeometry(5, 5); 
                const material = new THREE.MeshPhongMaterial({ 
                    map: texture,
                    transparent: true,
                    opacity: 0.5, 
                    blending: THREE.AdditiveBlending,
                    side: THREE.DoubleSide
                });
                
                bgPlane = new THREE.Mesh(geometry, material);
                // Push it further back so text doesn't clip into it
                bgPlane.position.z = -10; 
                scene.add(bgPlane);
            });
        }

        function createText() {
            letters = [];
            if(textMesh1) scene.remove(textMesh1);
            if(textMesh2) scene.remove(textMesh2);

            // Closer Y positions for tighter grouping
            createWord('MADHU', 1.5, true);
            createWord('MADHANAN', -1.5, false);
        }

        function createWord(text, yPos, isFirst) {
            const group = new THREE.Group();
            const isMobile = window.innerWidth < 768;
            // Tighter letter spacing
            const letterSpacing = isMobile ? 1.0 : 1.3;
            const totalWidth = text.length * letterSpacing;
            const startX = -totalWidth / 2;

            for (let i = 0; i < text.length; i++) {
                const letter = text[i];
                const letterMesh = createLetterMesh(letter);
                letterMesh.position.x = startX + i * letterSpacing + (letterSpacing/2);
                
                letterMesh.userData = {
                    initialY: yPos,
                    id: Math.random(),
                    isDestroyed: false,
                    offset: i
                };

                group.add(letterMesh);
                letters.push(letterMesh);
            }

            group.position.y = yPos;
            // Slight tilt back for perspective
            group.rotation.x = -0.1; 
            scene.add(group);

            if (isFirst) textMesh1 = group;
            else textMesh2 = group;
        }

        function createLetterMesh(char) {
            const shape = new THREE.Shape();
            const w = 0.4; const h = 1.0;
            
            const draw = {
                'M': () => { shape.moveTo(-w,0); shape.lineTo(-w,h); shape.lineTo(0,h/2); shape.lineTo(w,h); shape.lineTo(w,0); shape.lineTo(w/2,0); shape.lineTo(w/2,0.6); shape.lineTo(0,0.2); shape.lineTo(-w/2,0.6); shape.lineTo(-w/2,0); },
                'A': () => { shape.moveTo(-w,0); shape.lineTo(0,h); shape.lineTo(w,0); shape.lineTo(w/2,0); shape.lineTo(w/4,0.3); shape.lineTo(-w/4,0.3); shape.lineTo(-w/2,0); },
                'D': () => { shape.moveTo(-w,0); shape.lineTo(-w,h); shape.lineTo(0,h); shape.quadraticCurveTo(w,h,w,h/2); shape.quadraticCurveTo(w,0,0,0); },
                'H': () => { shape.moveTo(-w,0); shape.lineTo(-w,h); shape.lineTo(-w/2,h); shape.lineTo(-w/2,0.6); shape.lineTo(w/2,0.6); shape.lineTo(w/2,h); shape.lineTo(w,h); shape.lineTo(w,0); shape.lineTo(w/2,0); shape.lineTo(w/2,0.4); shape.lineTo(-w/2,0.4); shape.lineTo(-w/2,0); },
                'U': () => { shape.moveTo(-w,h); shape.lineTo(-w,0.3); shape.quadraticCurveTo(-w,0,0,0); shape.quadraticCurveTo(w,0,w,0.3); shape.lineTo(w,h); shape.lineTo(w/2,h); shape.lineTo(w/2,0.3); shape.quadraticCurveTo(w/2,0.2,0,0.2); shape.quadraticCurveTo(-w/2,0.2,-w/2,0.3); shape.lineTo(-w/2,h); },
                'N': () => { shape.moveTo(-w,0); shape.lineTo(-w,h); shape.lineTo(-w/2,h); shape.lineTo(w/2,0.3); shape.lineTo(w/2,h); shape.lineTo(w,h); shape.lineTo(w,0); shape.lineTo(w/2,0); shape.lineTo(-w/2,0.7); shape.lineTo(-w/2,0); }
            };

            if (draw[char]) draw[char]();
            else { shape.moveTo(-w,0); shape.lineTo(-w,h); shape.lineTo(w,h); shape.lineTo(w,0); }

            const geometry = new THREE.ExtrudeGeometry(shape, {
                depth: 0.3, // Thicker letters
                bevelEnabled: true,
                bevelThickness: 0.05,
                bevelSize: 0.03,
                bevelSegments: 4
            });
            geometry.center();

            const material = new THREE.MeshPhongMaterial({ 
                color: 0xaaccff, // Brighter blue-white
                emissive: 0x001133,
                shininess: 100,
                specular: 0xffffff
            });

            return new THREE.Mesh(geometry, material);
        }

        // NEW: Creates the moving warp starfield
        function createWarpField() {
            const geometry = new THREE.BufferGeometry();
            const positions = new Float32Array(SETTINGS.warpStarCount * 3);
            const colors = new THREE.Float32Array(SETTINGS.warpStarCount * 3);

            for (let i = 0; i < SETTINGS.warpStarCount; i++) {
                // Spread stars widely in X and Y, and deep into negative Z
                const x = (Math.random() - 0.5) * 200;
                const y = (Math.random() - 0.5) * 200;
                // Place stars far in the distance relative to camera
                const z = Math.random() * -300; 

                positions[i * 3] = x;
                positions[i * 3 + 1] = y;
                positions[i * 3 + 2] = z;

                // Color variation: White/Blue to Gold/Orange at edges
                const distanceFromCenter = Math.sqrt(x*x + y*y);
                let color;
                if(distanceFromCenter < 30) {
                     color = new THREE.Color(0xaaddff); // Blue center
                } else {
                     color = new THREE.Color(0xffaa55); // Orange edges
                }
                colors[i * 3] = color.r;
                colors[i * 3 + 1] = color.g;
                colors[i * 3 + 2] = color.b;
            }

            geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));

            const material = new THREE.PointsMaterial({
                size: 0.4, // Larger points for streak feel
                vertexColors: true,
                transparent: true,
                opacity: 0.8,
                blending: THREE.AdditiveBlending,
                // Simple texture to make points rounder/softer
                map: generateSprite()
            });

            warpStars = new THREE.Points(geometry, material);
            scene.add(warpStars);
        }

        // Helper for soft particles
        function generateSprite() {
            const canvas = document.createElement('canvas');
            canvas.width = 16; canvas.height = 16;
            const context = canvas.getContext('2d');
            const gradient = context.createRadialGradient(canvas.width / 2, canvas.height / 2, 0, canvas.width / 2, canvas.height / 2, canvas.width / 2);
            gradient.addColorStop(0, 'rgba(255,255,255,1)');
            gradient.addColorStop(0.4, 'rgba(100,150,255,0.5)');
            gradient.addColorStop(1, 'rgba(0,0,0,0)');
            context.fillStyle = gradient;
            context.fillRect(0, 0, canvas.width, canvas.height);
            return new THREE.CanvasTexture(canvas);
        }


        function createComets() {
            for (let i = 0; i < SETTINGS.cometCount; i++) {
                createSingleComet();
            }
        }

        function createSingleComet() {
            const geometry = new THREE.SphereGeometry(0.1, 8, 8);
            const material = new THREE.MeshBasicMaterial({ color: 0xffddaa, blending: THREE.AdditiveBlending });
            const comet = new THREE.Mesh(geometry, material);

            // Trail
            const trailGeo = new THREE.BufferGeometry();
            const positions = new Float32Array(20 * 3);
            trailGeo.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            const trailMat = new THREE.LineBasicMaterial({
                color: 0xff5500,
                transparent: true,
                opacity: 0.5,
                blending: THREE.AdditiveBlending
            });
            const trail = new THREE.Line(trailGeo, trailMat);
            scene.add(trail);

            comet.userData = {
                velocity: new THREE.Vector3(),
                trailMesh: trail,
                trailPoints: [],
            };
            
            resetComet(comet);
            scene.add(comet);
            comets.push(comet);
        }

        function resetComet(comet) {
            const liveLetters = letters.filter(l => !l.userData.isDestroyed);
            
            // Spawn further out
            comet.position.set(
                (Math.random() - 0.5) * 40,
                (Math.random() - 0.5) * 40,
                -50 // Start from deep space
            );

            let targetPos = new THREE.Vector3(0, 0, 0);
            if(liveLetters.length > 0) {
                const targetLetter = liveLetters[Math.floor(Math.random() * liveLetters.length)];
                targetLetter.getWorldPosition(targetPos);
                // Less jitter for more accurate hits in warp
                targetPos.x += (Math.random() - 0.5) * 0.5; 
            } else {
                targetPos.set((Math.random() - 0.5) * 5, (Math.random() - 0.5) * 5, 5);
            }

            const dir = new THREE.Vector3().subVectors(targetPos, comet.position).normalize();
            // Faster comets to match warp speed feel
            const speed = 0.8 + Math.random() * 0.5; 
            comet.userData.velocity = dir.multiplyScalar(speed);
            comet.userData.trailPoints = [];
        }

        function createExplosion(position) {
            const particleCount = 30;
            const geometry = new THREE.BufferGeometry();
            const positions = [];
            const velocities = [];

            for (let i = 0; i < particleCount; i++) {
                positions.push(position.x, position.y, position.z);
                // Explosions move faster forward with the warp
                velocities.push({
                    x: (Math.random() - 0.5) * 0.5,
                    y: (Math.random() - 0.5) * 0.5,
                    z: Math.random() * 0.8 // Forward bias
                });
            }

            geometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
            const material = new THREE.PointsMaterial({
                color: 0xff8800,
                size: 0.3,
                transparent: true,
                opacity: 1,
                blending: THREE.AdditiveBlending,
                map: warpStars.material.map // Reuse sprite
            });

            const explosion = new THREE.Points(geometry, material);
            explosion.userData = { velocities: velocities, life: 1.0 };
            scene.add(explosion);
            explosions.push(explosion);
        }

        function checkReset() {
            if(isResetting) return;
            const liveLetters = letters.filter(l => !l.userData.isDestroyed);
            if(liveLetters.length === 0 && letters.length > 0) {
                isResetting = true;
                document.getElementById('info').textContent = "SYSTEM CRITICAL - REBOOTING";
                setTimeout(() => {
                    letters.forEach(l => {
                        l.visible = true;
                        l.userData.isDestroyed = false;
                    });
                    document.getElementById('info').textContent = "ENGAGING WARP DRIVE";
                    isResetting = false;
                }, 2500);
            }
        }

        function animate() {
            requestAnimationFrame(animate);
            const time = Date.now() * 0.001;

            // 1. Animate Warp Field (The core perspective change)
            if (warpStars) {
                const positions = warpStars.geometry.attributes.position.array;
                for (let i = 0; i < SETTINGS.warpStarCount; i++) {
                    // Move star towards camera along Z axis
                    positions[i * 3 + 2] += SETTINGS.warpSpeed;

                    // If star passes camera (camera Z is around 12-18), reset it far back
                    if (positions[i * 3 + 2] > camera.position.z + 5) {
                        positions[i * 3 + 2] = -300; // Reset deep in background
                        // Optional: Reshuffle X/Y slightly for variance
                         positions[i * 3] = (Math.random() - 0.5) * 200;
                    }
                }
                warpStars.geometry.attributes.position.needsUpdate = true;
                // Rotate the whole field slowly for spiral effect
                warpStars.rotation.z += 0.001;
            }

            // 2. Subtle Image Movement
            if(bgPlane) {
                // Gentle swaying, less bouncy than before
                bgPlane.rotation.z = Math.sin(time * 0.2) * 0.02;
                bgPlane.position.z = -10 + Math.sin(time * 0.5) * 0.5; 
            }

            // 3. Text Animation (Removed the heavy bobbing)
            letters.forEach(letter => {
                if(!letter.userData.isDestroyed) {
                    const offset = letter.userData.offset;
                    // Very subtle floating rotation only
                    letter.rotation.y = Math.sin(time * 1.0 + offset * 0.2) * 0.05;
                    // Slight Z-shift based on index to give depth curve
                    letter.position.z = Math.abs(offset - 2.5) * -0.1;
                }
            });

            // Keep text groups relatively steady in Y
            if (textMesh1) textMesh1.position.y = 1.5;
            if (textMesh2) textMesh2.position.y = -1.5;


            // 4. Comet Physics & Collision (Existing logic adapted)
            const raycaster = new THREE.Raycaster();
            comets.forEach(comet => {
                comet.position.add(comet.userData.velocity);

                // Update Trail
                comet.userData.trailPoints.unshift(comet.position.clone());
                if(comet.userData.trailPoints.length > 15) comet.userData.trailPoints.pop();
                
                const positions = comet.userData.trailMesh.geometry.attributes.position.array;
                let idx = 0;
                comet.userData.trailPoints.forEach(p => { positions[idx++] = p.x; positions[idx++] = p.y; positions[idx++] = p.z; });
                while(idx < positions.length) { const last = comet.position; positions[idx++] = last.x; positions[idx++] = last.y; positions[idx++] = last.z; }
                comet.userData.trailMesh.geometry.attributes.position.needsUpdate = true;

                // Collision
                const direction = comet.userData.velocity.clone().normalize();
                raycaster.set(comet.position, direction);
                const livingMeshes = letters.filter(l => !l.userData.isDestroyed);
                const hitInfo = raycaster.intersectObjects(livingMeshes);
                
                // Increased hit distance slightly due to higher speeds
                if (hitInfo.length > 0 && hitInfo[0].distance < 0.8) {
                    const hitObject = hitInfo[0].object;
                    createExplosion(hitInfo[0].point);
                    hitObject.visible = false;
                    hitObject.userData.isDestroyed = true;
                    resetComet(comet);
                }

                // Reset if passed camera
                if(comet.position.z > camera.position.z + 5 || Math.abs(comet.position.x) > 40 || Math.abs(comet.position.y) > 40) {
                    resetComet(comet);
                }
            });

            // 5. Explosion Animation
            for(let i = explosions.length - 1; i >= 0; i--) {
                const exp = explosions[i];
                exp.userData.life -= 0.03; // Faster fade
                const pos = exp.geometry.attributes.position.array;
                const vels = exp.userData.velocities;
                for(let j = 0; j < vels.length; j++) {
                    pos[j*3] += vels[j].x; pos[j*3+1] += vels[j].y; pos[j*3+2] += vels[j].z;
                }
                exp.geometry.attributes.position.needsUpdate = true;
                exp.material.opacity = exp.userData.life;
                // Scale down as they fade
                exp.scale.setScalar(exp.userData.life);
                if(exp.userData.life <= 0) { scene.remove(exp); explosions.splice(i, 1); }
            }

            checkReset();
            renderer.render(scene, camera);
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            camera.position.z = window.innerWidth < 768 ? 18 : 12;
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        window.addEventListener('resize', onWindowResize);
        window.addEventListener('load', init);
    </script>
</body>
</html>
